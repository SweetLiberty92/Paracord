// E2EE sender key lifecycle management.
// Each sender generates an ephemeral AES-128 key per voice session.
// Key distributed to participants encrypted to each recipient's X25519 identity key.

// ================================================================
// Cross-platform interop test vectors (AES-128-GCM)
// ================================================================
// These test vectors are generated by the Rust FrameEncryptor in
// crates/paracord-codec/src/crypto.rs. The TypeScript implementation
// below MUST produce identical ciphertext for the same inputs.
// AES-128-GCM is deterministic for identical (key, nonce, plaintext, AAD).
//
// Nonce layout: SSRC (4 bytes BE) || epoch (1 byte) || sequence (2 bytes BE) || 5 zero bytes = 12 bytes
// AAD: the full 16-byte MediaHeader
// Output: ciphertext || 16-byte GCM authentication tag
//
// --- Vector 1: Standard voice frame ---
//   Key:       000102030405060708090a0b0c0d0e0f
//   SSRC:      0xDEADBEEF
//   Epoch:     1
//   Sequence:  1
//   Nonce:     deadbeef 01 0001 0000000000
//   Header:    80000100 0003c0de adbeef7f 01003c00
//   Plaintext: "Hello, voice data!" (UTF-8, 18 bytes)
//   Expected:  c9611e22e84a7843baeea950f4874840d7de76e45bab8f2dc788366fe73643bb62f5
//   (18 bytes ciphertext + 16 bytes tag = 34 bytes)
//
// --- Vector 2: Empty payload (tag-only) ---
//   Key:       000102030405060708090a0b0c0d0e0f
//   SSRC:      0xDEADBEEF
//   Epoch:     1
//   Sequence:  0
//   Nonce:     deadbeef 01 0000 0000000000
//   Header:    80000100 0003c0de adbeef7f 01003c00
//   Plaintext: (empty, 0 bytes)
//   Expected:  e4ee5cfea6b77f20fcb4d7c719b1f0a4
//   (0 bytes ciphertext + 16 bytes tag = 16 bytes)
//
// --- Vector 3: Different key/epoch/SSRC ---
//   Key:       ffffffffffffffffffffffffffffffff
//   SSRC:      0x11223344
//   Epoch:     5
//   Sequence:  10
//   Nonce:     11223344 05 000a 0000000000
//   Header:    8000 0a00 00078011 22334464 05000400
//   Plaintext: 00010203 (4 bytes)
//   Expected:  81c292b9fd8c98a87d786ee1f5698993b50ae66d
//   (4 bytes ciphertext + 16 bytes tag = 20 bytes)
// ================================================================

/** Callback type for key distribution events. */
export type KeyDistributionCallback = (
  rawKey: Uint8Array,
  epoch: number,
  recipientUserIds: string[],
) => void;

/** Callback type for key rotation notifications. */
export type KeyRotationCallback = (reason: 'join' | 'leave', userId: string) => void;

export class SenderKeyManager {
  private localKey: CryptoKey | null = null;
  private localEpoch = 0;
  private localRawKey: Uint8Array | null = null;
  private peerKeys: Map<string, CryptoKey> = new Map(); // "ssrc:epoch" -> key
  private participantIds: Set<string> = new Set();
  private onKeyDistribution: KeyDistributionCallback | null = null;
  private onKeyRotation: KeyRotationCallback | null = null;

  /** Register a callback invoked when a new key needs to be distributed. */
  setKeyDistributionCallback(cb: KeyDistributionCallback): void {
    this.onKeyDistribution = cb;
  }

  /** Register a callback invoked when key rotation is triggered. */
  setKeyRotationCallback(cb: KeyRotationCallback): void {
    this.onKeyRotation = cb;
  }

  /** Generate a new AES-128 sender key, incrementing the epoch. */
  async generateKey(): Promise<{ key: CryptoKey; epoch: number }> {
    this.localEpoch++;
    this.localKey = await crypto.subtle.generateKey(
      { name: 'AES-GCM', length: 128 },
      true,
      ['encrypt', 'decrypt'],
    );
    // Cache the raw key bytes for distribution.
    const raw = await crypto.subtle.exportKey('raw', this.localKey);
    this.localRawKey = new Uint8Array(raw);
    return { key: this.localKey, epoch: this.localEpoch };
  }

  /**
   * Rotate the local sender key: generate a new key with incremented epoch.
   * Returns both the old and new key material for any in-flight transition.
   */
  async rotateKey(): Promise<{
    oldKey: Uint8Array | null;
    oldEpoch: number;
    newKey: Uint8Array;
    newEpoch: number;
  }> {
    const oldKey = this.localRawKey;
    const oldEpoch = this.localEpoch;

    await this.generateKey();

    // Distribute the new key to all current participants.
    if (this.onKeyDistribution && this.localRawKey) {
      this.onKeyDistribution(
        this.localRawKey,
        this.localEpoch,
        Array.from(this.participantIds),
      );
    }

    return {
      oldKey,
      oldEpoch,
      newKey: this.localRawKey!,
      newEpoch: this.localEpoch,
    };
  }

  /**
   * Handle a new participant joining the voice session.
   * Triggers key rotation for backward secrecy (the new participant
   * cannot decrypt media sent before they joined).
   */
  async handleParticipantJoin(userId: string): Promise<void> {
    this.participantIds.add(userId);

    // Rotate key so the new participant cannot decrypt old media.
    await this.rotateKey();

    this.onKeyRotation?.('join', userId);
  }

  /**
   * Handle a participant leaving the voice session.
   * Triggers key rotation for forward secrecy (the departed participant
   * cannot decrypt media sent after they left).
   */
  async handleParticipantLeave(userId: string): Promise<void> {
    this.participantIds.delete(userId);

    // Remove all peer keys for this user (all epochs).
    // Keys stored as "ssrc:epoch" - we can't directly map userId to ssrc here,
    // but the caller should also call removePeerKeys(ssrc) for cleanup.

    // Rotate key so the departed participant cannot decrypt future media.
    await this.rotateKey();

    this.onKeyRotation?.('leave', userId);
  }

  /**
   * Handle a late-joiner request: send the current key to a newly joined participant.
   * This is called when the relay notifies us that a new participant needs our key.
   */
  async handleLateJoinerRequest(recipientUserId: string): Promise<void> {
    if (!this.localRawKey) {
      return; // No key to send (we haven't started sending yet).
    }
    this.onKeyDistribution?.(this.localRawKey, this.localEpoch, [recipientUserId]);
  }

  /** Remove all stored peer keys for a given SSRC (all epochs). */
  removePeerKeys(ssrc: number): void {
    for (const key of this.peerKeys.keys()) {
      if (key.startsWith(`${ssrc}:`)) {
        this.peerKeys.delete(key);
      }
    }
  }

  /** Get the set of current participant IDs. */
  getParticipants(): ReadonlySet<string> {
    return this.participantIds;
  }

  /**
   * Encrypt a media frame payload.
   * Nonce (12 bytes): SSRC (4) || epoch (1) || sequence (2) || 5 zero bytes
   * AAD: the 16-byte MediaHeader
   */
  async encrypt(
    header: Uint8Array,
    payload: Uint8Array,
    epoch: number,
    sequence: number,
    ssrc: number,
  ): Promise<Uint8Array> {
    if (!this.localKey) {
      throw new Error('No local sender key generated');
    }
    const iv = this.buildNonce(ssrc, epoch, sequence);
    const ciphertext = await crypto.subtle.encrypt(
      {
        name: 'AES-GCM',
        iv: iv.buffer as ArrayBuffer,
        additionalData: header.buffer as ArrayBuffer,
      },
      this.localKey,
      payload.buffer as ArrayBuffer,
    );
    return new Uint8Array(ciphertext);
  }

  /**
   * Decrypt a received media frame payload.
   * Uses the peer's sender key identified by SSRC + epoch.
   */
  async decrypt(
    header: Uint8Array,
    payload: Uint8Array,
    epoch: number,
    sequence: number,
    ssrc: number,
  ): Promise<Uint8Array> {
    const peerKey = this.peerKeys.get(`${ssrc}:${epoch}`);
    if (!peerKey) {
      throw new Error(`No sender key for SSRC ${ssrc} epoch ${epoch}`);
    }
    const iv = this.buildNonce(ssrc, epoch, sequence);
    const plaintext = await crypto.subtle.decrypt(
      {
        name: 'AES-GCM',
        iv: iv.buffer as ArrayBuffer,
        additionalData: header.buffer as ArrayBuffer,
      },
      peerKey,
      payload.buffer as ArrayBuffer,
    );
    return new Uint8Array(plaintext);
  }

  /** Store a received peer's sender key. */
  setPeerKey(ssrc: number, epoch: number, key: CryptoKey): void {
    this.peerKeys.set(`${ssrc}:${epoch}`, key);
  }

  /** Import a raw key bytes buffer as a peer key. */
  async importPeerKey(ssrc: number, epoch: number, rawKey: Uint8Array): Promise<void> {
    const key = await crypto.subtle.importKey(
      'raw',
      rawKey.buffer as ArrayBuffer,
      { name: 'AES-GCM', length: 128 },
      false,
      ['decrypt'],
    );
    this.setPeerKey(ssrc, epoch, key);
  }

  /** Export the local key as raw bytes for distribution. */
  async exportKey(): Promise<Uint8Array> {
    if (!this.localKey) {
      throw new Error('No local sender key generated');
    }
    const raw = await crypto.subtle.exportKey('raw', this.localKey);
    return new Uint8Array(raw);
  }

  get currentEpoch(): number {
    return this.localEpoch;
  }

  /**
   * Build a 12-byte nonce for AES-GCM.
   * Layout: SSRC (4 bytes BE) || epoch (1 byte) || sequence (2 bytes BE) || 5 zero bytes
   */
  private buildNonce(ssrc: number, epoch: number, sequence: number): Uint8Array {
    const nonce = new Uint8Array(12);
    const view = new DataView(nonce.buffer as ArrayBuffer);
    view.setUint32(0, ssrc, false);
    nonce[4] = epoch & 0xff;
    view.setUint16(5, sequence, false);
    // bytes 7-11 remain zero
    return nonce;
  }
}
